# 小知识点

## for click循环问题

```js
const lists = document.querySelectorAll('li')
for(var i = 0; i < lists.length; i++) {
  lists[i].onclick = function () {
    alert(i)
  }
}
```

**问题：** 上面的代码，每次点击的时候都是alert(3)

**原因：** 作用域问题，在点击的时候再去取i的值，已经是lists.length了，使用let创建i，不会出现这个问题

**解决方法:** 使用闭包 或者 使用let创建i

```js
// 闭包解决
const lists = document.querySelectorAll('li')
for(var i = 0; i < lists.length; i++) {
  (function() {
    lists[i].onclick = function() {
      alert(i)
    }
  })(i)
}
```

**原因：** 在上面的情况中，i是全局变量，在onclick时间触发的时候，访问的是全局变量i，所以i一直都是3，如果放在闭包中执行，实参传递到形参的时候，非引用类型的实参会复制一份给形参，而不是共享一份

## class实例

```js
class People {
  constructor(name) {
    this.name = name || 'people'
  }

  print() {
    return `print: ${this.name}`
  }
}
class Teacher extends People {
  constructor(name, className) {
    super(name)
    this.class = className || 'one'
  }
}

const people = new People('Tom')

console.log (people.name)
console.log (people.print())


const teacher = new Teacher('Peter', 'One Class')
console.log (teacher.name)
console.log (teacher.class)
console.log (teacher.print())

```

## JS中两种定时器，setTimeout和setInterval的区别

- **setTimeout** 只在指定时间后执行一次
- **setInterval** 以制定时间为周期循环执行

### 使用setTimeout模拟setInterval和直接使用setInterval的区别

```js
var callback = function () {
    if (times++ > max) {
        clearTimeout(timeoutId);
        clearInterval(intervalId);
    }

    console.log('start', Date.now() - start);
    for (var i = 0; i < 990000000; i++) {}
    console.log('end', Date.now() - start);
},
delay = 100,
times = 0,
max = 5,
start = Date.now(),
intervalId,
timeoutId;

function imitateInterval(fn, delay) {
    timeoutId = setTimeout(function () {
        fn();

        if (times <= max) {
            imitateInterval(fn ,delay);
        }
    }, delay);
}

imitateInterval(callback, delay);
intervalId = setInterval(callback, delay);
```

区别在于：setTimeout回调完成后才会调用下一次定时器，而setInterval则不管回调函数的执行结果，当达到规定时间就会在事件队列中插入一个执行回调的事件，所以在选择setInterval执行事件时需要考虑这种特性是否会对业务代码产生影响

## JS判断给出年份的1月1号星期几

```js
// 比如，求2018年1月1号是星期几
const year = 2018

const date = new Date(`${year}-01-01`)
const weekDay=new Array("星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六")

console.log(weekDay[date.getDay()])

```

## 使用闭包完成click a标签，弹出序号

```js
const links = document.querySelectorAll('a')
let i = 1
links.forEach(link => {
  link.onclick = (function(i) {
    return function() {
        alert(i)
    }
  })(i)
  i++
})
```

## JS原理（变量提升）

```js
var foo = 1
function main() {
    alert(foo)
    var foo = 2
    alert(this.foo)
    this.foo = 3
}

var m1 = main() // undefined(foo在main()函数域中还未定义) , 1(this.foo)
var m2 = new main() // undefined(同上), undefined(新实例对象指向m2,即m2.foo不存在，为undefined)
```

## 类数组转伪数组方法

```js
const lists = document.querySelectorAll('li')

// 1.for循环添加 略
// 2.es6新方法
Array.from(lists)
// 3.数组原生方法
Array.prototype.slice.call(lists)

```

## let和var的区别

- let为块级作用域，var函数作用域
- let不存在变量提升

## attribute和property的区别

attribute是dom元素在文档中作为html标签拥有的属性；

property就是dom元素在js中作为对象拥有的属性。

## == 与 === 的区别

== 在简单类型之间和 **简单类型与复杂类型** 比较前会进行类型转换， 而 === 不会。复杂类型 == 与 === 相同，都是进行地址的比较

```js

null == undefined // true
null === undefined // false

```

## script标签中的defer 与 async属性

![img](https://www.peterchen.club/imgs/defer-async.png)

## CommonJS 中的 require/exports 和 ES6 中的 import/export 区别

CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。

ES6 模块是动态引用，如果使用 import 从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用

import/export 最终都是编译为 require/exports 来执行的。

## JS基本类型与引用类型

1. 基本类型： string,number,boolean,null,undefined 【操作和保存在变量的实际的值】
2. 引用类型： Function,Array,Object 【值保存在内存中，js不允许直接访问内存，在操作的时候，操作的是对象的引用】

## 事件冒泡例外

不是所有事件都可以冒泡，其中blur, focus, load, unload不能冒泡

## 作用域链

作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的