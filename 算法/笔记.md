# 笔记

## 复杂度分析

### 时间复杂度

- 代码执行时间T(n)和代码执行次数成正比
- 大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度
- 分析时间复杂度，只关注执行次数最多的一段代码
- 加法法则：总复杂度等于量级最大的那段代码的复杂度
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
- 复杂度量级
  - 多项式量级
    - 常数 1
    - 对数 logn
    - 线性 n
    - 线性对数 nlogn
    - 平方 n^2
    - 立方 n^3
    - k次方 n^k
  - 非多项式量级（NP（Non-Deterministic Polynomial，非确定多项式）问题）
    - 指数阶 2^n
    - 阶乘 n!
- 分类
  - 最好情况时间复杂度
  - 最坏情况时间复杂度
  - 平均情况时间复杂度
  - 均摊时间复杂度
    - 特殊的平均时间复杂度
    - 均摊耗时的操作到o(1)上
  
## 数组

- 数组是一种线性表数据结构
- 用一组连续的内存空间，存储同类型数据
- 和链表的关系
  - 数组支持随机访问，时间复杂度o(1)，但是插入删除较为低效，平均情况时间复杂度为 O(n)
  - 链表适合增删结点，时间复杂度o(1)

## 链表

- 经典场景（LRU内存淘汰算法）
- 插入和删除数据非常快，但随机访问效率低
- 类型
  - 单链表
  - 双向链表
    - 支持o(1)找到前驱结点
  - 循环链表
  - 双向循环链表
- 双向链表比单链表使用场景多，是空间换时间的典型
- 检查代码的边界条件：
  - 链表为空
  - 链表只包含一个节点
  - 链表只包含两个节点
  - 处理头尾节点

## 栈

- 栈是一种操作受限的数据结构，只支持入栈和出栈操作
- 栈可以用来计算表达式
  - 使用两个栈（符号 / 数值）
  - 遇到低优先级的符号，则数值出栈计算
  - 然后继续比较前一个符号与当前符号的优先级

## 队列

- 队列是一种操作受限的数据结构，只支持入队和出队操作
- 队列出队，指针后移，会导致可用空间和剩余空间不对齐，可以改造入队函数，在入队时搬移数据即可
- 特殊队列
  - 循环队列：可以解决上面说的搬移问题，但是队尾没法放置元素
  - 阻塞队列：队头没有元素的时候阻塞出队操作
  - 并发队列：入队出队操作加锁
- 线程池等待实现：
  - 链式队列：无限排队的无界队列
  - 数组实现的有界队列：超过队列长度的请求被拒绝


## 递归

- 递归需要满足三个条件：
  - 可以被分解为子问题
  - 子问题求解思路完全一致
  - 存在递归终止条件
- 典型题目：爬楼梯
  - f(n) = f(n-1) + f(n-2)
- 递归需要避免重复计算
- 递归可以优化为迭代循环的非递归写法

## 排序

### 冒泡排序 Bubble Sort

- 定义：一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作
- 优化：如果一轮冒泡操作中没有数据交换时，说明已经达到完全有序，不需要继续后续的冒泡操作了
- 空间复杂度：O(1)，是一个原地排序算法
- 稳定性：是稳定性算法，值相等时不交换
- 时间复杂度：
  - 最好情况下：数据有序，O(n)
  - 最坏情况下：o(n^2)
  - 平均时间复杂度：就是加权平均期望时间复杂度，O(n^2)
    - 可以通过 **有序度** 和 **逆序度** 来分析
      - 有序度：即为有序元素对的个数
        - 满有序度： n*(n-1)/2
      - 逆序度 = 满有序度 - 有序度

### 插入排序 Insertion Sort

- 定义：动态地往有序集合中添加数据
- 空间复杂度：O(1)，是一个原地排序算法
- 稳定性：是稳定性算法，值相等时向后插入
- 时间复杂度：
  - 最好情况下：数据有序，从后往前遍历插入区间，O(n)
  - 最坏情况下：o(n^2)
- 和冒泡排序相比，虽然时间复杂度相同，但是赋值操作较少，更为推荐

### 选择排序 Selection Sort

- 定义：选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾
- 空间复杂度：O(1)，是一个原地排序算法
- 稳定性：不稳定，在交换过程中，会导致
- 时间复杂度：
  - 最好情况下：o(n^2)
  - 最坏情况下：o(n^2)

### 归并排序 Merge Sort （递归）

- 定义：归并排序使用的就是分治思想，通过分解再合并，即能完成排序要求
- 稳定性：稳定，控制合并逻辑即可
- 时间复杂度：
  - 递归的时间复杂度分析：T(a) = T(b) + T(c) + K
  - O(nlogn)
  - 不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)
- 空间复杂度：O(n)，递归过程中只会有一个函数在执行，所以不是nlogn
- merge函数功能：
  - 按序合并数组

### 快速排序 Quick Sort （递归）

- 定义：选一个区分点，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间，经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的
- 空间复杂度：O(1)，是一个原地排序算法
- 稳定性：不稳定，涉及交换
- partion函数功能：
  - 将数组按照定义组织，跟插入排序类似
- 时间复杂度：o(nlogn)
  - 但是如果分区元素选的不好，会退化为o(n^2)

> 归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题
> 求解第K大数据的时间复杂度是O(n)，可以用快排的思路来分析

### 桶排序 Bucket Sort

- 定义：核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了
- 时间复杂度：O(n)
- 要求：
  - 桶排序比较适合用在外部排序中
  - 桶的顺序是有序的
- 注意点：
  - 桶内数据如果不均分，则容易退化为O(nlogn)
      - 可以通过继续分桶来解决

### 计数排序 Counting Sort

- 定义：计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间
- 计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，
- 计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数（因为需要对应数组下标）
- 时间复杂度：O(n)

### 基数排序 Radix Sort

- 定义：先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了
- 排序算法一定要是稳定的，否则会打乱之前的排序结果
- 基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了
- 每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了

### 实现高性能排序算法

- 线性排序不适用，归并排序和快速排序中选择快排，因为归并排序需要占用额外空间
- 快速排序的时间复杂度恶化问题需要解决
  - 原因在于选取的分区点不合理，希望是分开的两侧数据量差不多，下面有几种方法解决这个问题：
    - 三数取中法
      - 首、尾、中间选取一个数，将中间值设置为分区点
      - 可以根据数据量，调整取数逻辑
    - 随机法

#### 举例分析 qsort()

- qsort() 会优先使用归并排序来排序输入数据
- 要排序的数据量比较大的时候，qsort() 会改为用快速排序算法来排序
  - qsort() 选择分区点的方法就是“三数取中法”
- 当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为插入排序，不再继续用递归来做快速排序

## 二分查找 Binary Search

- 定义：二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0
- 时间复杂度：O(logn)，查找区间大小逐步减半
- 局限性
  - 依赖顺序表结构
  - 有序数据
  - 数据量
    - 太小可以遍历
    - 太大存不进去

### 递归与非递归实现

- 非递归实现 - 循环
  - 注意点：
    - 循环退出条件
    - mid的取值
      - low + ((high - low) >> 1)
    - low 和 high的更新
      - low = mid + 1
      - high = mid - 1
- 递归实现
  - 循环改为递归调用判断逻辑

### 查找第一个值给定的元素

```
如果 mid 等于 0，那这个元素已经是数组的第一个元素，那它肯定是我们要找的；如果 mid 不等于 0，但 a[mid]的前一个元素 a[mid-1]不等于 value，那也说明 a[mid]就是我们要找的第一个值等于给定值的元素
```

### 查找最后一个值等于给定值的元素

```
如果 a[mid]这个元素已经是数组中的最后一个元素了，那它肯定是我们要找的；如果 a[mid]的后一个元素 a[mid+1]不等于 value，那也说明 a[mid]就是我们要找的最后一个值等于给定值的元素
```

### 查找第一个大于等于给定值的元素

```
如果 a[mid]小于要查找的值 value，那要查找的值肯定在[mid+1, high]之间，所以，我们更新 low=mid+1。对于 a[mid]大于等于给定值 value 的情况，我们要先看下这个 a[mid]是不是我们要找的第一个值大于等于给定值的元素。如果 a[mid]前面已经没有元素，或者前面一个元素小于要查找的值 value，那 a[mid]就是我们要找的元素
```

### 查找最后一个小于等于给定值的元素

同上

### 总结

二分查找更适合用在“近似”查找问题，在这类问题上，二分查找的优势更加明显。比如今天讲的这几种变体问题，用其他数据结构，比如散列表、二叉树，就比较难实现了

## 跳表 Skip list

- 定义：这种链表加多级索引的结构，就是跳表
- 时间复杂度：O(m*logn) 【m为结点个数】
- 空间复杂度：O(n)
- 插入、删除操作的时间复杂度也是 O(logn)
- 跳表是通过随机函数来维护前面提到的“平衡性”
  - 通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中
- 使用空间换时间的设计思路

## 散列表

- 散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表
- 散列函数
  - 