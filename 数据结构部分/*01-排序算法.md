# 排序算法小结

<!-- TOC -->

- [排序算法小结](#排序算法小结)
  - [冒泡排序(O(n^2))](#冒泡排序on^2)
  - [选择排序](#选择排序)
  - [插入排序](#插入排序)
  - [归并排序](#归并排序)
  - [希尔排序](#希尔排序)
  - [快速排序](#快速排序)
  - [堆排序](#堆排序)

<!-- /TOC -->

## 冒泡排序(O(n^2))

将最大数置底

```js
function swap(myArray, p1, p2){
  var temp = myArray[p1];
  myArray[p1] = myArray[p2];
  myArray[p2] = temp;
}
function bubbleSort(myArray){
  var len = myArray.length;
  var i;
  var j;
  var stop;

  for (i = 0; i < len - 1; i++){
    for (j = 0, stop = len - 1 - i; j < stop; j++){
      if (myArray[j] > myArray[j + 1]){
        swap(myArray, j, j + 1);
      }
    }
  }

  return myArray;
}
bubbleSort([1,3,4,2,5,6])
```

## 选择排序

将第一个元素和其他元素进行比较，检查完所有元素后,最小的元素会被放到数组的第一个位置

```js
function selectionSort(arr) {
  let min
  let temp
  let length = arr.length
  // 因为到倒数第二个的时候，全部数组就已经排好序了
  for(let i = 0; i < length - 2; i++) {
    min = arr[i]
    for(let j = i + 1; j < length - 1; j++) {
      if(arr[j] < min) {
        min = arr[j]
        swap(arr, j, i)
      }
    }
  }
  return arr
}
selectionSort([1,3,4,2,5,6])
```

## 插入排序

插入未排序数到已排序的结果数组

> 相比于冒泡排序，如果数组已经有序，则时间复杂度为O(n)

```js
function insertionSort(arr) {
  let sortedArrIndex
  let tempValue
  let length = arr.length
  for(let i = 1; i < length - 1; i++) {
    sortedArrIndex = i
    tempValue = arr[i]
    while(sortedArrIndex > 0 && (arr[sortedArrIndex - 1] > tempValue)) {
      // 插入
      arr[sortedArrIndex] = arr[sortedArrIndex - 1]
      sortedArrIndex--
    }
    arr[sortedArrIndex] = tempValue
  }
  return arr
}
console.log(insertionSort([1,3,4,2,5,6]))
```

## 归并排序

把一系列排好序的子序列，合并成一个大的完整有序序列

> 但是需要较大的空间存储数据,数据较大时容易溢出,是一个自底向上的过程

```js
function merge(left, right) {
  let temp = []
  while(left.length && right.length) {
    if(left[0] > right[0]) {
      temp.push(right.shift())
    } else {
      temp.push(left.shift())
    }
  }
  return temp.concat(left, right)
}

function mergeSort(arr) {
  let length = arr.length
  if(length < 2) {
    return arr
  }
  let mid = Math.floor(length / 2)
  let left = arr.slice(0, mid)
  let right = arr.slice(mid)
  return merge(mergeSort(left), mergeSort(right))
}
console.log(mergeSort([1,3,4,2,5,6]))
```

## 希尔排序

## 快速排序

## 堆排序